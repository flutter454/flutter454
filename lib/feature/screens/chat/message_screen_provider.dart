import 'dart:async';

import 'package:chatloop/feature/screens/chat/chat_service.dart';
import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class MessageScreenProvider with ChangeNotifier {
  final ChatService _chatService = ChatService();
  late final String _currentUserId;

  // State Variables
  List<Map<String, dynamic>> _messages = [];
  final List<Map<String, dynamic>> _optimisticMessages = [];
  final Set<String> _deletedMessageIds = {};
  Map<String, dynamic>? _replyToMessage;
  StreamSubscription<List<Map<String, dynamic>>>? _messagesSubscription;
  bool _isLoading = true;
  String? _error;

  // Getters
  List<Map<String, dynamic>> get messages {
    // Combine server messages and optimistic messages
    // Filter out deleted messages
    final combined = [
      ..._messages,
      ..._optimisticMessages,
    ].where((msg) => !_deletedMessageIds.contains(msg['id'])).toList();

    // Sort? Usually server returns sorted, but we can ensure sort if needed.
    // Assuming stream returns sorted by created_at.
    return combined;
  }

  Map<String, dynamic>? get replyToMessage => _replyToMessage;
  bool get isLoading => _isLoading;
  String? get error => _error;
  String get currentUserId => _currentUserId;

  // Initialization
  void init(String chatId) {
    _currentUserId = Supabase.instance.client.auth.currentUser!.id;
    _subscribeToMessages(chatId);
    _markAsSeen(chatId);
  }

  void _subscribeToMessages(String chatId) {
    _isLoading = true;
    _error = null;
    notifyListeners();

    _messagesSubscription?.cancel();
    _messagesSubscription = _chatService
        .getMessagesStream(chatId)
        .listen(
          (data) {
            _messages = data;
            _isLoading = false;

            // Clean up optimistic messages that are now in server data
            // We remove any optimistic message whose ID is present in the server data
            // Note: Use a temp ID strategy if real ID is generated by server,
            // but here we generate ID locally for optimistic?
            // In previous code: tempId = DateTime.now().toIso8601String()
            // But actual insertion likely relies on Supabase ID generation?
            // Wait, chat_service.dart insert doesn't return ID.
            // So we can't match easily unless we match by content/timestamp or just clear all optimistic once we get data?
            // The previous logic cleared optimistic message by ID.
            // But if the server ID is different, it won't clear.
            // And chat_service.sendMessage doesn't take ID.
            // So the optimistic message stays unless we clear it manually or match by content.
            // Let's keep the manual removal logic for now (done in sendMessage),
            // OR better: in sendMessage we wait for completion and then remove.
            // The stream update is independent.

            notifyListeners();
          },
          onError: (e) {
            _error = e.toString();
            _isLoading = false;
            notifyListeners();
          },
        );
  }

  Future<void> _markAsSeen(String chatId) async {
    await _chatService.markMessagesAsSeen(chatId, _currentUserId);
  }

  // Actions
  void setReplyTo(Map<String, dynamic> message) {
    _replyToMessage = message;
    notifyListeners();
  }

  void clearReply() {
    _replyToMessage = null;
    notifyListeners();
  }

  Future<void> sendMessage(String chatId, String text) async {
    if (text.trim().isEmpty) return;

    final tempId = DateTime.now().toIso8601String();
    final optimisticMsg = {
      'id': tempId,
      'text': text.trim(),
      'sender_id': _currentUserId,
      'created_at': DateTime.now().toIso8601String(),
      'is_seen': false,
      'is_optimistic': true,
      if (_replyToMessage != null)
        'reply_to': _replyToMessage, // Store reply context if supported?
      // Note: Backend schema might not support reply_to yet, but UI can use local state.
    };

    _optimisticMessages.add(optimisticMsg);
    // Clear reply after sending
    _replyToMessage = null;
    notifyListeners();

    try {
      await _chatService.sendMessage(chatId, _currentUserId, text);

      // Remove optimistic message.
      // The stream will eventually bring the real message.
      // Ideally we match by ID but since we don't have real ID back from insert (void return),
      // we just remove the optimistic one immediately upon success?
      // Or wait for stream? If we remove immediately, there might be a flicker if stream is slow.
      // But keeping it creates duplicate.
      // Since specific ID matching is impossible without returning ID, we remove it.
      _optimisticMessages.removeWhere((m) => m['id'] == tempId);
      notifyListeners();
    } catch (e) {
      debugPrint('Error sending message: $e');
      // Keep optimistic message or mark as error?
      // For now, remove it to avoid confusion or add error state.
      _optimisticMessages.removeWhere((m) => m['id'] == tempId);
      _error = "Failed to send message";
      notifyListeners();
    }
  }

  Future<void> unsendMessage(String messageId) async {
    // Add to deleted set for instant UI update
    _deletedMessageIds.add(messageId);

    // Also remove from optimistic if it exists there
    _optimisticMessages.removeWhere((m) => m['id'] == messageId);

    notifyListeners();

    try {
      await _chatService.removeMessage(messageId);
    } catch (e) {
      debugPrint('Error un-sending message: $e');
      // Undo deletion?
      _deletedMessageIds.remove(messageId);
      notifyListeners();
      rethrow;
    }
  }

  @override
  void dispose() {
    _messagesSubscription?.cancel();
    super.dispose();
  }
}
